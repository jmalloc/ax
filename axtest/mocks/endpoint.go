// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/jmalloc/ax"
	"github.com/jmalloc/ax/endpoint"
	"sync"
)

var (
	lockInboundPipelineMockAccept     sync.RWMutex
	lockInboundPipelineMockInitialize sync.RWMutex
)

// Ensure, that InboundPipelineMock does implement InboundPipeline.
// If this is not the case, regenerate this file with moq.
var _ endpoint.InboundPipeline = &InboundPipelineMock{}

// InboundPipelineMock is a mock implementation of InboundPipeline.
//
//     func TestSomethingThatUsesInboundPipeline(t *testing.T) {
//
//         // make and configure a mocked InboundPipeline
//         mockedInboundPipeline := &InboundPipelineMock{
//             AcceptFunc: func(ctx context.Context, sink endpoint.MessageSink, env endpoint.InboundEnvelope) error {
// 	               panic("mock out the Accept method")
//             },
//             InitializeFunc: func(ctx context.Context, ep *endpoint.Endpoint) error {
// 	               panic("mock out the Initialize method")
//             },
//         }
//
//         // use mockedInboundPipeline in code that requires InboundPipeline
//         // and then make assertions.
//
//     }
type InboundPipelineMock struct {
	// AcceptFunc mocks the Accept method.
	AcceptFunc func(ctx context.Context, sink endpoint.MessageSink, env endpoint.InboundEnvelope) error

	// InitializeFunc mocks the Initialize method.
	InitializeFunc func(ctx context.Context, ep *endpoint.Endpoint) error

	// calls tracks calls to the methods.
	calls struct {
		// Accept holds details about calls to the Accept method.
		Accept []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sink is the sink argument value.
			Sink endpoint.MessageSink
			// Env is the env argument value.
			Env endpoint.InboundEnvelope
		}
		// Initialize holds details about calls to the Initialize method.
		Initialize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ep is the ep argument value.
			Ep *endpoint.Endpoint
		}
	}
}

// Accept calls AcceptFunc.
func (mock *InboundPipelineMock) Accept(ctx context.Context, sink endpoint.MessageSink, env endpoint.InboundEnvelope) error {
	if mock.AcceptFunc == nil {
		panic("InboundPipelineMock.AcceptFunc: method is nil but InboundPipeline.Accept was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Sink endpoint.MessageSink
		Env  endpoint.InboundEnvelope
	}{
		Ctx:  ctx,
		Sink: sink,
		Env:  env,
	}
	lockInboundPipelineMockAccept.Lock()
	mock.calls.Accept = append(mock.calls.Accept, callInfo)
	lockInboundPipelineMockAccept.Unlock()
	return mock.AcceptFunc(ctx, sink, env)
}

// AcceptCalls gets all the calls that were made to Accept.
// Check the length with:
//     len(mockedInboundPipeline.AcceptCalls())
func (mock *InboundPipelineMock) AcceptCalls() []struct {
	Ctx  context.Context
	Sink endpoint.MessageSink
	Env  endpoint.InboundEnvelope
} {
	var calls []struct {
		Ctx  context.Context
		Sink endpoint.MessageSink
		Env  endpoint.InboundEnvelope
	}
	lockInboundPipelineMockAccept.RLock()
	calls = mock.calls.Accept
	lockInboundPipelineMockAccept.RUnlock()
	return calls
}

// Initialize calls InitializeFunc.
func (mock *InboundPipelineMock) Initialize(ctx context.Context, ep *endpoint.Endpoint) error {
	if mock.InitializeFunc == nil {
		panic("InboundPipelineMock.InitializeFunc: method is nil but InboundPipeline.Initialize was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ep  *endpoint.Endpoint
	}{
		Ctx: ctx,
		Ep:  ep,
	}
	lockInboundPipelineMockInitialize.Lock()
	mock.calls.Initialize = append(mock.calls.Initialize, callInfo)
	lockInboundPipelineMockInitialize.Unlock()
	return mock.InitializeFunc(ctx, ep)
}

// InitializeCalls gets all the calls that were made to Initialize.
// Check the length with:
//     len(mockedInboundPipeline.InitializeCalls())
func (mock *InboundPipelineMock) InitializeCalls() []struct {
	Ctx context.Context
	Ep  *endpoint.Endpoint
} {
	var calls []struct {
		Ctx context.Context
		Ep  *endpoint.Endpoint
	}
	lockInboundPipelineMockInitialize.RLock()
	calls = mock.calls.Initialize
	lockInboundPipelineMockInitialize.RUnlock()
	return calls
}

var (
	lockMessageSinkMockAccept sync.RWMutex
)

// Ensure, that MessageSinkMock does implement MessageSink.
// If this is not the case, regenerate this file with moq.
var _ endpoint.MessageSink = &MessageSinkMock{}

// MessageSinkMock is a mock implementation of MessageSink.
//
//     func TestSomethingThatUsesMessageSink(t *testing.T) {
//
//         // make and configure a mocked MessageSink
//         mockedMessageSink := &MessageSinkMock{
//             AcceptFunc: func(ctx context.Context, env endpoint.OutboundEnvelope) error {
// 	               panic("mock out the Accept method")
//             },
//         }
//
//         // use mockedMessageSink in code that requires MessageSink
//         // and then make assertions.
//
//     }
type MessageSinkMock struct {
	// AcceptFunc mocks the Accept method.
	AcceptFunc func(ctx context.Context, env endpoint.OutboundEnvelope) error

	// calls tracks calls to the methods.
	calls struct {
		// Accept holds details about calls to the Accept method.
		Accept []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Env is the env argument value.
			Env endpoint.OutboundEnvelope
		}
	}
}

// Accept calls AcceptFunc.
func (mock *MessageSinkMock) Accept(ctx context.Context, env endpoint.OutboundEnvelope) error {
	if mock.AcceptFunc == nil {
		panic("MessageSinkMock.AcceptFunc: method is nil but MessageSink.Accept was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
	}{
		Ctx: ctx,
		Env: env,
	}
	lockMessageSinkMockAccept.Lock()
	mock.calls.Accept = append(mock.calls.Accept, callInfo)
	lockMessageSinkMockAccept.Unlock()
	return mock.AcceptFunc(ctx, env)
}

// AcceptCalls gets all the calls that were made to Accept.
// Check the length with:
//     len(mockedMessageSink.AcceptCalls())
func (mock *MessageSinkMock) AcceptCalls() []struct {
	Ctx context.Context
	Env endpoint.OutboundEnvelope
} {
	var calls []struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
	}
	lockMessageSinkMockAccept.RLock()
	calls = mock.calls.Accept
	lockMessageSinkMockAccept.RUnlock()
	return calls
}

var (
	lockOutboundPipelineMockAccept     sync.RWMutex
	lockOutboundPipelineMockInitialize sync.RWMutex
)

// Ensure, that OutboundPipelineMock does implement OutboundPipeline.
// If this is not the case, regenerate this file with moq.
var _ endpoint.OutboundPipeline = &OutboundPipelineMock{}

// OutboundPipelineMock is a mock implementation of OutboundPipeline.
//
//     func TestSomethingThatUsesOutboundPipeline(t *testing.T) {
//
//         // make and configure a mocked OutboundPipeline
//         mockedOutboundPipeline := &OutboundPipelineMock{
//             AcceptFunc: func(ctx context.Context, env endpoint.OutboundEnvelope) error {
// 	               panic("mock out the Accept method")
//             },
//             InitializeFunc: func(ctx context.Context, ep *endpoint.Endpoint) error {
// 	               panic("mock out the Initialize method")
//             },
//         }
//
//         // use mockedOutboundPipeline in code that requires OutboundPipeline
//         // and then make assertions.
//
//     }
type OutboundPipelineMock struct {
	// AcceptFunc mocks the Accept method.
	AcceptFunc func(ctx context.Context, env endpoint.OutboundEnvelope) error

	// InitializeFunc mocks the Initialize method.
	InitializeFunc func(ctx context.Context, ep *endpoint.Endpoint) error

	// calls tracks calls to the methods.
	calls struct {
		// Accept holds details about calls to the Accept method.
		Accept []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Env is the env argument value.
			Env endpoint.OutboundEnvelope
		}
		// Initialize holds details about calls to the Initialize method.
		Initialize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ep is the ep argument value.
			Ep *endpoint.Endpoint
		}
	}
}

// Accept calls AcceptFunc.
func (mock *OutboundPipelineMock) Accept(ctx context.Context, env endpoint.OutboundEnvelope) error {
	if mock.AcceptFunc == nil {
		panic("OutboundPipelineMock.AcceptFunc: method is nil but OutboundPipeline.Accept was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
	}{
		Ctx: ctx,
		Env: env,
	}
	lockOutboundPipelineMockAccept.Lock()
	mock.calls.Accept = append(mock.calls.Accept, callInfo)
	lockOutboundPipelineMockAccept.Unlock()
	return mock.AcceptFunc(ctx, env)
}

// AcceptCalls gets all the calls that were made to Accept.
// Check the length with:
//     len(mockedOutboundPipeline.AcceptCalls())
func (mock *OutboundPipelineMock) AcceptCalls() []struct {
	Ctx context.Context
	Env endpoint.OutboundEnvelope
} {
	var calls []struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
	}
	lockOutboundPipelineMockAccept.RLock()
	calls = mock.calls.Accept
	lockOutboundPipelineMockAccept.RUnlock()
	return calls
}

// Initialize calls InitializeFunc.
func (mock *OutboundPipelineMock) Initialize(ctx context.Context, ep *endpoint.Endpoint) error {
	if mock.InitializeFunc == nil {
		panic("OutboundPipelineMock.InitializeFunc: method is nil but OutboundPipeline.Initialize was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ep  *endpoint.Endpoint
	}{
		Ctx: ctx,
		Ep:  ep,
	}
	lockOutboundPipelineMockInitialize.Lock()
	mock.calls.Initialize = append(mock.calls.Initialize, callInfo)
	lockOutboundPipelineMockInitialize.Unlock()
	return mock.InitializeFunc(ctx, ep)
}

// InitializeCalls gets all the calls that were made to Initialize.
// Check the length with:
//     len(mockedOutboundPipeline.InitializeCalls())
func (mock *OutboundPipelineMock) InitializeCalls() []struct {
	Ctx context.Context
	Ep  *endpoint.Endpoint
} {
	var calls []struct {
		Ctx context.Context
		Ep  *endpoint.Endpoint
	}
	lockOutboundPipelineMockInitialize.RLock()
	calls = mock.calls.Initialize
	lockOutboundPipelineMockInitialize.RUnlock()
	return calls
}

var (
	lockSelfValidatingMessageMockMessageDescription sync.RWMutex
	lockSelfValidatingMessageMockProtoMessage       sync.RWMutex
	lockSelfValidatingMessageMockReset              sync.RWMutex
	lockSelfValidatingMessageMockString             sync.RWMutex
	lockSelfValidatingMessageMockValidate           sync.RWMutex
)

// Ensure, that SelfValidatingMessageMock does implement SelfValidatingMessage.
// If this is not the case, regenerate this file with moq.
var _ endpoint.SelfValidatingMessage = &SelfValidatingMessageMock{}

// SelfValidatingMessageMock is a mock implementation of SelfValidatingMessage.
//
//     func TestSomethingThatUsesSelfValidatingMessage(t *testing.T) {
//
//         // make and configure a mocked SelfValidatingMessage
//         mockedSelfValidatingMessage := &SelfValidatingMessageMock{
//             MessageDescriptionFunc: func() string {
// 	               panic("mock out the MessageDescription method")
//             },
//             ProtoMessageFunc: func()  {
// 	               panic("mock out the ProtoMessage method")
//             },
//             ResetFunc: func()  {
// 	               panic("mock out the Reset method")
//             },
//             StringFunc: func() string {
// 	               panic("mock out the String method")
//             },
//             ValidateFunc: func() error {
// 	               panic("mock out the Validate method")
//             },
//         }
//
//         // use mockedSelfValidatingMessage in code that requires SelfValidatingMessage
//         // and then make assertions.
//
//     }
type SelfValidatingMessageMock struct {
	// MessageDescriptionFunc mocks the MessageDescription method.
	MessageDescriptionFunc func() string

	// ProtoMessageFunc mocks the ProtoMessage method.
	ProtoMessageFunc func()

	// ResetFunc mocks the Reset method.
	ResetFunc func()

	// StringFunc mocks the String method.
	StringFunc func() string

	// ValidateFunc mocks the Validate method.
	ValidateFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// MessageDescription holds details about calls to the MessageDescription method.
		MessageDescription []struct {
		}
		// ProtoMessage holds details about calls to the ProtoMessage method.
		ProtoMessage []struct {
		}
		// Reset holds details about calls to the Reset method.
		Reset []struct {
		}
		// String holds details about calls to the String method.
		String []struct {
		}
		// Validate holds details about calls to the Validate method.
		Validate []struct {
		}
	}
}

// MessageDescription calls MessageDescriptionFunc.
func (mock *SelfValidatingMessageMock) MessageDescription() string {
	if mock.MessageDescriptionFunc == nil {
		panic("SelfValidatingMessageMock.MessageDescriptionFunc: method is nil but SelfValidatingMessage.MessageDescription was just called")
	}
	callInfo := struct {
	}{}
	lockSelfValidatingMessageMockMessageDescription.Lock()
	mock.calls.MessageDescription = append(mock.calls.MessageDescription, callInfo)
	lockSelfValidatingMessageMockMessageDescription.Unlock()
	return mock.MessageDescriptionFunc()
}

// MessageDescriptionCalls gets all the calls that were made to MessageDescription.
// Check the length with:
//     len(mockedSelfValidatingMessage.MessageDescriptionCalls())
func (mock *SelfValidatingMessageMock) MessageDescriptionCalls() []struct {
} {
	var calls []struct {
	}
	lockSelfValidatingMessageMockMessageDescription.RLock()
	calls = mock.calls.MessageDescription
	lockSelfValidatingMessageMockMessageDescription.RUnlock()
	return calls
}

// ProtoMessage calls ProtoMessageFunc.
func (mock *SelfValidatingMessageMock) ProtoMessage() {
	if mock.ProtoMessageFunc == nil {
		panic("SelfValidatingMessageMock.ProtoMessageFunc: method is nil but SelfValidatingMessage.ProtoMessage was just called")
	}
	callInfo := struct {
	}{}
	lockSelfValidatingMessageMockProtoMessage.Lock()
	mock.calls.ProtoMessage = append(mock.calls.ProtoMessage, callInfo)
	lockSelfValidatingMessageMockProtoMessage.Unlock()
	mock.ProtoMessageFunc()
}

// ProtoMessageCalls gets all the calls that were made to ProtoMessage.
// Check the length with:
//     len(mockedSelfValidatingMessage.ProtoMessageCalls())
func (mock *SelfValidatingMessageMock) ProtoMessageCalls() []struct {
} {
	var calls []struct {
	}
	lockSelfValidatingMessageMockProtoMessage.RLock()
	calls = mock.calls.ProtoMessage
	lockSelfValidatingMessageMockProtoMessage.RUnlock()
	return calls
}

// Reset calls ResetFunc.
func (mock *SelfValidatingMessageMock) Reset() {
	if mock.ResetFunc == nil {
		panic("SelfValidatingMessageMock.ResetFunc: method is nil but SelfValidatingMessage.Reset was just called")
	}
	callInfo := struct {
	}{}
	lockSelfValidatingMessageMockReset.Lock()
	mock.calls.Reset = append(mock.calls.Reset, callInfo)
	lockSelfValidatingMessageMockReset.Unlock()
	mock.ResetFunc()
}

// ResetCalls gets all the calls that were made to Reset.
// Check the length with:
//     len(mockedSelfValidatingMessage.ResetCalls())
func (mock *SelfValidatingMessageMock) ResetCalls() []struct {
} {
	var calls []struct {
	}
	lockSelfValidatingMessageMockReset.RLock()
	calls = mock.calls.Reset
	lockSelfValidatingMessageMockReset.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *SelfValidatingMessageMock) String() string {
	if mock.StringFunc == nil {
		panic("SelfValidatingMessageMock.StringFunc: method is nil but SelfValidatingMessage.String was just called")
	}
	callInfo := struct {
	}{}
	lockSelfValidatingMessageMockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	lockSelfValidatingMessageMockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//     len(mockedSelfValidatingMessage.StringCalls())
func (mock *SelfValidatingMessageMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	lockSelfValidatingMessageMockString.RLock()
	calls = mock.calls.String
	lockSelfValidatingMessageMockString.RUnlock()
	return calls
}

// Validate calls ValidateFunc.
func (mock *SelfValidatingMessageMock) Validate() error {
	if mock.ValidateFunc == nil {
		panic("SelfValidatingMessageMock.ValidateFunc: method is nil but SelfValidatingMessage.Validate was just called")
	}
	callInfo := struct {
	}{}
	lockSelfValidatingMessageMockValidate.Lock()
	mock.calls.Validate = append(mock.calls.Validate, callInfo)
	lockSelfValidatingMessageMockValidate.Unlock()
	return mock.ValidateFunc()
}

// ValidateCalls gets all the calls that were made to Validate.
// Check the length with:
//     len(mockedSelfValidatingMessage.ValidateCalls())
func (mock *SelfValidatingMessageMock) ValidateCalls() []struct {
} {
	var calls []struct {
	}
	lockSelfValidatingMessageMockValidate.RLock()
	calls = mock.calls.Validate
	lockSelfValidatingMessageMockValidate.RUnlock()
	return calls
}

var (
	lockInboundTransportMockInitialize sync.RWMutex
	lockInboundTransportMockReceive    sync.RWMutex
	lockInboundTransportMockSubscribe  sync.RWMutex
)

// Ensure, that InboundTransportMock does implement InboundTransport.
// If this is not the case, regenerate this file with moq.
var _ endpoint.InboundTransport = &InboundTransportMock{}

// InboundTransportMock is a mock implementation of InboundTransport.
//
//     func TestSomethingThatUsesInboundTransport(t *testing.T) {
//
//         // make and configure a mocked InboundTransport
//         mockedInboundTransport := &InboundTransportMock{
//             InitializeFunc: func(ctx context.Context, ep string) error {
// 	               panic("mock out the Initialize method")
//             },
//             ReceiveFunc: func(ctx context.Context) (endpoint.InboundEnvelope, endpoint.Acknowledger, error) {
// 	               panic("mock out the Receive method")
//             },
//             SubscribeFunc: func(ctx context.Context, op endpoint.Operation, mt ax.MessageTypeSet) error {
// 	               panic("mock out the Subscribe method")
//             },
//         }
//
//         // use mockedInboundTransport in code that requires InboundTransport
//         // and then make assertions.
//
//     }
type InboundTransportMock struct {
	// InitializeFunc mocks the Initialize method.
	InitializeFunc func(ctx context.Context, ep string) error

	// ReceiveFunc mocks the Receive method.
	ReceiveFunc func(ctx context.Context) (endpoint.InboundEnvelope, endpoint.Acknowledger, error)

	// SubscribeFunc mocks the Subscribe method.
	SubscribeFunc func(ctx context.Context, op endpoint.Operation, mt ax.MessageTypeSet) error

	// calls tracks calls to the methods.
	calls struct {
		// Initialize holds details about calls to the Initialize method.
		Initialize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ep is the ep argument value.
			Ep string
		}
		// Receive holds details about calls to the Receive method.
		Receive []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Subscribe holds details about calls to the Subscribe method.
		Subscribe []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Op is the op argument value.
			Op endpoint.Operation
			// Mt is the mt argument value.
			Mt ax.MessageTypeSet
		}
	}
}

// Initialize calls InitializeFunc.
func (mock *InboundTransportMock) Initialize(ctx context.Context, ep string) error {
	if mock.InitializeFunc == nil {
		panic("InboundTransportMock.InitializeFunc: method is nil but InboundTransport.Initialize was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ep  string
	}{
		Ctx: ctx,
		Ep:  ep,
	}
	lockInboundTransportMockInitialize.Lock()
	mock.calls.Initialize = append(mock.calls.Initialize, callInfo)
	lockInboundTransportMockInitialize.Unlock()
	return mock.InitializeFunc(ctx, ep)
}

// InitializeCalls gets all the calls that were made to Initialize.
// Check the length with:
//     len(mockedInboundTransport.InitializeCalls())
func (mock *InboundTransportMock) InitializeCalls() []struct {
	Ctx context.Context
	Ep  string
} {
	var calls []struct {
		Ctx context.Context
		Ep  string
	}
	lockInboundTransportMockInitialize.RLock()
	calls = mock.calls.Initialize
	lockInboundTransportMockInitialize.RUnlock()
	return calls
}

// Receive calls ReceiveFunc.
func (mock *InboundTransportMock) Receive(ctx context.Context) (endpoint.InboundEnvelope, endpoint.Acknowledger, error) {
	if mock.ReceiveFunc == nil {
		panic("InboundTransportMock.ReceiveFunc: method is nil but InboundTransport.Receive was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	lockInboundTransportMockReceive.Lock()
	mock.calls.Receive = append(mock.calls.Receive, callInfo)
	lockInboundTransportMockReceive.Unlock()
	return mock.ReceiveFunc(ctx)
}

// ReceiveCalls gets all the calls that were made to Receive.
// Check the length with:
//     len(mockedInboundTransport.ReceiveCalls())
func (mock *InboundTransportMock) ReceiveCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	lockInboundTransportMockReceive.RLock()
	calls = mock.calls.Receive
	lockInboundTransportMockReceive.RUnlock()
	return calls
}

// Subscribe calls SubscribeFunc.
func (mock *InboundTransportMock) Subscribe(ctx context.Context, op endpoint.Operation, mt ax.MessageTypeSet) error {
	if mock.SubscribeFunc == nil {
		panic("InboundTransportMock.SubscribeFunc: method is nil but InboundTransport.Subscribe was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Op  endpoint.Operation
		Mt  ax.MessageTypeSet
	}{
		Ctx: ctx,
		Op:  op,
		Mt:  mt,
	}
	lockInboundTransportMockSubscribe.Lock()
	mock.calls.Subscribe = append(mock.calls.Subscribe, callInfo)
	lockInboundTransportMockSubscribe.Unlock()
	return mock.SubscribeFunc(ctx, op, mt)
}

// SubscribeCalls gets all the calls that were made to Subscribe.
// Check the length with:
//     len(mockedInboundTransport.SubscribeCalls())
func (mock *InboundTransportMock) SubscribeCalls() []struct {
	Ctx context.Context
	Op  endpoint.Operation
	Mt  ax.MessageTypeSet
} {
	var calls []struct {
		Ctx context.Context
		Op  endpoint.Operation
		Mt  ax.MessageTypeSet
	}
	lockInboundTransportMockSubscribe.RLock()
	calls = mock.calls.Subscribe
	lockInboundTransportMockSubscribe.RUnlock()
	return calls
}

var (
	lockOutboundTransportMockInitialize sync.RWMutex
	lockOutboundTransportMockSend       sync.RWMutex
)

// Ensure, that OutboundTransportMock does implement OutboundTransport.
// If this is not the case, regenerate this file with moq.
var _ endpoint.OutboundTransport = &OutboundTransportMock{}

// OutboundTransportMock is a mock implementation of OutboundTransport.
//
//     func TestSomethingThatUsesOutboundTransport(t *testing.T) {
//
//         // make and configure a mocked OutboundTransport
//         mockedOutboundTransport := &OutboundTransportMock{
//             InitializeFunc: func(ctx context.Context, ep string) error {
// 	               panic("mock out the Initialize method")
//             },
//             SendFunc: func(ctx context.Context, env endpoint.OutboundEnvelope) error {
// 	               panic("mock out the Send method")
//             },
//         }
//
//         // use mockedOutboundTransport in code that requires OutboundTransport
//         // and then make assertions.
//
//     }
type OutboundTransportMock struct {
	// InitializeFunc mocks the Initialize method.
	InitializeFunc func(ctx context.Context, ep string) error

	// SendFunc mocks the Send method.
	SendFunc func(ctx context.Context, env endpoint.OutboundEnvelope) error

	// calls tracks calls to the methods.
	calls struct {
		// Initialize holds details about calls to the Initialize method.
		Initialize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ep is the ep argument value.
			Ep string
		}
		// Send holds details about calls to the Send method.
		Send []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Env is the env argument value.
			Env endpoint.OutboundEnvelope
		}
	}
}

// Initialize calls InitializeFunc.
func (mock *OutboundTransportMock) Initialize(ctx context.Context, ep string) error {
	if mock.InitializeFunc == nil {
		panic("OutboundTransportMock.InitializeFunc: method is nil but OutboundTransport.Initialize was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ep  string
	}{
		Ctx: ctx,
		Ep:  ep,
	}
	lockOutboundTransportMockInitialize.Lock()
	mock.calls.Initialize = append(mock.calls.Initialize, callInfo)
	lockOutboundTransportMockInitialize.Unlock()
	return mock.InitializeFunc(ctx, ep)
}

// InitializeCalls gets all the calls that were made to Initialize.
// Check the length with:
//     len(mockedOutboundTransport.InitializeCalls())
func (mock *OutboundTransportMock) InitializeCalls() []struct {
	Ctx context.Context
	Ep  string
} {
	var calls []struct {
		Ctx context.Context
		Ep  string
	}
	lockOutboundTransportMockInitialize.RLock()
	calls = mock.calls.Initialize
	lockOutboundTransportMockInitialize.RUnlock()
	return calls
}

// Send calls SendFunc.
func (mock *OutboundTransportMock) Send(ctx context.Context, env endpoint.OutboundEnvelope) error {
	if mock.SendFunc == nil {
		panic("OutboundTransportMock.SendFunc: method is nil but OutboundTransport.Send was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
	}{
		Ctx: ctx,
		Env: env,
	}
	lockOutboundTransportMockSend.Lock()
	mock.calls.Send = append(mock.calls.Send, callInfo)
	lockOutboundTransportMockSend.Unlock()
	return mock.SendFunc(ctx, env)
}

// SendCalls gets all the calls that were made to Send.
// Check the length with:
//     len(mockedOutboundTransport.SendCalls())
func (mock *OutboundTransportMock) SendCalls() []struct {
	Ctx context.Context
	Env endpoint.OutboundEnvelope
} {
	var calls []struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
	}
	lockOutboundTransportMockSend.RLock()
	calls = mock.calls.Send
	lockOutboundTransportMockSend.RUnlock()
	return calls
}

var (
	lockValidatorMockValidate sync.RWMutex
)

// Ensure, that ValidatorMock does implement Validator.
// If this is not the case, regenerate this file with moq.
var _ endpoint.Validator = &ValidatorMock{}

// ValidatorMock is a mock implementation of Validator.
//
//     func TestSomethingThatUsesValidator(t *testing.T) {
//
//         // make and configure a mocked Validator
//         mockedValidator := &ValidatorMock{
//             ValidateFunc: func(ctx context.Context, m ax.Message) error {
// 	               panic("mock out the Validate method")
//             },
//         }
//
//         // use mockedValidator in code that requires Validator
//         // and then make assertions.
//
//     }
type ValidatorMock struct {
	// ValidateFunc mocks the Validate method.
	ValidateFunc func(ctx context.Context, m ax.Message) error

	// calls tracks calls to the methods.
	calls struct {
		// Validate holds details about calls to the Validate method.
		Validate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// M is the m argument value.
			M ax.Message
		}
	}
}

// Validate calls ValidateFunc.
func (mock *ValidatorMock) Validate(ctx context.Context, m ax.Message) error {
	if mock.ValidateFunc == nil {
		panic("ValidatorMock.ValidateFunc: method is nil but Validator.Validate was just called")
	}
	callInfo := struct {
		Ctx context.Context
		M   ax.Message
	}{
		Ctx: ctx,
		M:   m,
	}
	lockValidatorMockValidate.Lock()
	mock.calls.Validate = append(mock.calls.Validate, callInfo)
	lockValidatorMockValidate.Unlock()
	return mock.ValidateFunc(ctx, m)
}

// ValidateCalls gets all the calls that were made to Validate.
// Check the length with:
//     len(mockedValidator.ValidateCalls())
func (mock *ValidatorMock) ValidateCalls() []struct {
	Ctx context.Context
	M   ax.Message
} {
	var calls []struct {
		Ctx context.Context
		M   ax.Message
	}
	lockValidatorMockValidate.RLock()
	calls = mock.calls.Validate
	lockValidatorMockValidate.RUnlock()
	return calls
}
