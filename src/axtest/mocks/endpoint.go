// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/jmalloc/ax/src/ax"
	"github.com/jmalloc/ax/src/ax/endpoint"
	"sync"
)

var (
	lockInboundPipelineMockAccept     sync.RWMutex
	lockInboundPipelineMockInitialize sync.RWMutex
)

// InboundPipelineMock is a mock implementation of InboundPipeline.
//
//     func TestSomethingThatUsesInboundPipeline(t *testing.T) {
//
//         // make and configure a mocked InboundPipeline
//         mockedInboundPipeline := &InboundPipelineMock{
//             AcceptFunc: func(ctx context.Context, sink endpoint.MessageSink, env endpoint.InboundEnvelope) error {
// 	               panic("TODO: mock out the Accept method")
//             },
//             InitializeFunc: func(ctx context.Context, ep *endpoint.Endpoint) error {
// 	               panic("TODO: mock out the Initialize method")
//             },
//         }
//
//         // TODO: use mockedInboundPipeline in code that requires InboundPipeline
//         //       and then make assertions.
//
//     }
type InboundPipelineMock struct {
	// AcceptFunc mocks the Accept method.
	AcceptFunc func(ctx context.Context, sink endpoint.MessageSink, env endpoint.InboundEnvelope) error

	// InitializeFunc mocks the Initialize method.
	InitializeFunc func(ctx context.Context, ep *endpoint.Endpoint) error

	// calls tracks calls to the methods.
	calls struct {
		// Accept holds details about calls to the Accept method.
		Accept []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sink is the sink argument value.
			Sink endpoint.MessageSink
			// Env is the env argument value.
			Env endpoint.InboundEnvelope
		}
		// Initialize holds details about calls to the Initialize method.
		Initialize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ep is the ep argument value.
			Ep *endpoint.Endpoint
		}
	}
}

// Accept calls AcceptFunc.
func (mock *InboundPipelineMock) Accept(ctx context.Context, sink endpoint.MessageSink, env endpoint.InboundEnvelope) error {
	if mock.AcceptFunc == nil {
		panic("moq: InboundPipelineMock.AcceptFunc is nil but InboundPipeline.Accept was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Sink endpoint.MessageSink
		Env  endpoint.InboundEnvelope
	}{
		Ctx:  ctx,
		Sink: sink,
		Env:  env,
	}
	lockInboundPipelineMockAccept.Lock()
	mock.calls.Accept = append(mock.calls.Accept, callInfo)
	lockInboundPipelineMockAccept.Unlock()
	return mock.AcceptFunc(ctx, sink, env)
}

// AcceptCalls gets all the calls that were made to Accept.
// Check the length with:
//     len(mockedInboundPipeline.AcceptCalls())
func (mock *InboundPipelineMock) AcceptCalls() []struct {
	Ctx  context.Context
	Sink endpoint.MessageSink
	Env  endpoint.InboundEnvelope
} {
	var calls []struct {
		Ctx  context.Context
		Sink endpoint.MessageSink
		Env  endpoint.InboundEnvelope
	}
	lockInboundPipelineMockAccept.RLock()
	calls = mock.calls.Accept
	lockInboundPipelineMockAccept.RUnlock()
	return calls
}

// Initialize calls InitializeFunc.
func (mock *InboundPipelineMock) Initialize(ctx context.Context, ep *endpoint.Endpoint) error {
	if mock.InitializeFunc == nil {
		panic("moq: InboundPipelineMock.InitializeFunc is nil but InboundPipeline.Initialize was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ep  *endpoint.Endpoint
	}{
		Ctx: ctx,
		Ep:  ep,
	}
	lockInboundPipelineMockInitialize.Lock()
	mock.calls.Initialize = append(mock.calls.Initialize, callInfo)
	lockInboundPipelineMockInitialize.Unlock()
	return mock.InitializeFunc(ctx, ep)
}

// InitializeCalls gets all the calls that were made to Initialize.
// Check the length with:
//     len(mockedInboundPipeline.InitializeCalls())
func (mock *InboundPipelineMock) InitializeCalls() []struct {
	Ctx context.Context
	Ep  *endpoint.Endpoint
} {
	var calls []struct {
		Ctx context.Context
		Ep  *endpoint.Endpoint
	}
	lockInboundPipelineMockInitialize.RLock()
	calls = mock.calls.Initialize
	lockInboundPipelineMockInitialize.RUnlock()
	return calls
}

var (
	lockMessageSinkMockAccept sync.RWMutex
)

// MessageSinkMock is a mock implementation of MessageSink.
//
//     func TestSomethingThatUsesMessageSink(t *testing.T) {
//
//         // make and configure a mocked MessageSink
//         mockedMessageSink := &MessageSinkMock{
//             AcceptFunc: func(ctx context.Context, env endpoint.OutboundEnvelope) error {
// 	               panic("TODO: mock out the Accept method")
//             },
//         }
//
//         // TODO: use mockedMessageSink in code that requires MessageSink
//         //       and then make assertions.
//
//     }
type MessageSinkMock struct {
	// AcceptFunc mocks the Accept method.
	AcceptFunc func(ctx context.Context, env endpoint.OutboundEnvelope) error

	// calls tracks calls to the methods.
	calls struct {
		// Accept holds details about calls to the Accept method.
		Accept []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Env is the env argument value.
			Env endpoint.OutboundEnvelope
		}
	}
}

// Accept calls AcceptFunc.
func (mock *MessageSinkMock) Accept(ctx context.Context, env endpoint.OutboundEnvelope) error {
	if mock.AcceptFunc == nil {
		panic("moq: MessageSinkMock.AcceptFunc is nil but MessageSink.Accept was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
	}{
		Ctx: ctx,
		Env: env,
	}
	lockMessageSinkMockAccept.Lock()
	mock.calls.Accept = append(mock.calls.Accept, callInfo)
	lockMessageSinkMockAccept.Unlock()
	return mock.AcceptFunc(ctx, env)
}

// AcceptCalls gets all the calls that were made to Accept.
// Check the length with:
//     len(mockedMessageSink.AcceptCalls())
func (mock *MessageSinkMock) AcceptCalls() []struct {
	Ctx context.Context
	Env endpoint.OutboundEnvelope
} {
	var calls []struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
	}
	lockMessageSinkMockAccept.RLock()
	calls = mock.calls.Accept
	lockMessageSinkMockAccept.RUnlock()
	return calls
}

var (
	lockOutboundPipelineMockAccept     sync.RWMutex
	lockOutboundPipelineMockInitialize sync.RWMutex
)

// OutboundPipelineMock is a mock implementation of OutboundPipeline.
//
//     func TestSomethingThatUsesOutboundPipeline(t *testing.T) {
//
//         // make and configure a mocked OutboundPipeline
//         mockedOutboundPipeline := &OutboundPipelineMock{
//             AcceptFunc: func(ctx context.Context, env endpoint.OutboundEnvelope) error {
// 	               panic("TODO: mock out the Accept method")
//             },
//             InitializeFunc: func(ctx context.Context, ep *endpoint.Endpoint) error {
// 	               panic("TODO: mock out the Initialize method")
//             },
//         }
//
//         // TODO: use mockedOutboundPipeline in code that requires OutboundPipeline
//         //       and then make assertions.
//
//     }
type OutboundPipelineMock struct {
	// AcceptFunc mocks the Accept method.
	AcceptFunc func(ctx context.Context, env endpoint.OutboundEnvelope) error

	// InitializeFunc mocks the Initialize method.
	InitializeFunc func(ctx context.Context, ep *endpoint.Endpoint) error

	// calls tracks calls to the methods.
	calls struct {
		// Accept holds details about calls to the Accept method.
		Accept []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Env is the env argument value.
			Env endpoint.OutboundEnvelope
		}
		// Initialize holds details about calls to the Initialize method.
		Initialize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ep is the ep argument value.
			Ep *endpoint.Endpoint
		}
	}
}

// Accept calls AcceptFunc.
func (mock *OutboundPipelineMock) Accept(ctx context.Context, env endpoint.OutboundEnvelope) error {
	if mock.AcceptFunc == nil {
		panic("moq: OutboundPipelineMock.AcceptFunc is nil but OutboundPipeline.Accept was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
	}{
		Ctx: ctx,
		Env: env,
	}
	lockOutboundPipelineMockAccept.Lock()
	mock.calls.Accept = append(mock.calls.Accept, callInfo)
	lockOutboundPipelineMockAccept.Unlock()
	return mock.AcceptFunc(ctx, env)
}

// AcceptCalls gets all the calls that were made to Accept.
// Check the length with:
//     len(mockedOutboundPipeline.AcceptCalls())
func (mock *OutboundPipelineMock) AcceptCalls() []struct {
	Ctx context.Context
	Env endpoint.OutboundEnvelope
} {
	var calls []struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
	}
	lockOutboundPipelineMockAccept.RLock()
	calls = mock.calls.Accept
	lockOutboundPipelineMockAccept.RUnlock()
	return calls
}

// Initialize calls InitializeFunc.
func (mock *OutboundPipelineMock) Initialize(ctx context.Context, ep *endpoint.Endpoint) error {
	if mock.InitializeFunc == nil {
		panic("moq: OutboundPipelineMock.InitializeFunc is nil but OutboundPipeline.Initialize was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ep  *endpoint.Endpoint
	}{
		Ctx: ctx,
		Ep:  ep,
	}
	lockOutboundPipelineMockInitialize.Lock()
	mock.calls.Initialize = append(mock.calls.Initialize, callInfo)
	lockOutboundPipelineMockInitialize.Unlock()
	return mock.InitializeFunc(ctx, ep)
}

// InitializeCalls gets all the calls that were made to Initialize.
// Check the length with:
//     len(mockedOutboundPipeline.InitializeCalls())
func (mock *OutboundPipelineMock) InitializeCalls() []struct {
	Ctx context.Context
	Ep  *endpoint.Endpoint
} {
	var calls []struct {
		Ctx context.Context
		Ep  *endpoint.Endpoint
	}
	lockOutboundPipelineMockInitialize.RLock()
	calls = mock.calls.Initialize
	lockOutboundPipelineMockInitialize.RUnlock()
	return calls
}

var (
	lockSelfValidatingMessageMockMessageDescription sync.RWMutex
	lockSelfValidatingMessageMockProtoMessage       sync.RWMutex
	lockSelfValidatingMessageMockReset              sync.RWMutex
	lockSelfValidatingMessageMockString             sync.RWMutex
	lockSelfValidatingMessageMockValidate           sync.RWMutex
)

// SelfValidatingMessageMock is a mock implementation of SelfValidatingMessage.
//
//     func TestSomethingThatUsesSelfValidatingMessage(t *testing.T) {
//
//         // make and configure a mocked SelfValidatingMessage
//         mockedSelfValidatingMessage := &SelfValidatingMessageMock{
//             MessageDescriptionFunc: func() string {
// 	               panic("TODO: mock out the MessageDescription method")
//             },
//             ProtoMessageFunc: func()  {
// 	               panic("TODO: mock out the ProtoMessage method")
//             },
//             ResetFunc: func()  {
// 	               panic("TODO: mock out the Reset method")
//             },
//             StringFunc: func() string {
// 	               panic("TODO: mock out the String method")
//             },
//             ValidateFunc: func() error {
// 	               panic("TODO: mock out the Validate method")
//             },
//         }
//
//         // TODO: use mockedSelfValidatingMessage in code that requires SelfValidatingMessage
//         //       and then make assertions.
//
//     }
type SelfValidatingMessageMock struct {
	// MessageDescriptionFunc mocks the MessageDescription method.
	MessageDescriptionFunc func() string

	// ProtoMessageFunc mocks the ProtoMessage method.
	ProtoMessageFunc func()

	// ResetFunc mocks the Reset method.
	ResetFunc func()

	// StringFunc mocks the String method.
	StringFunc func() string

	// ValidateFunc mocks the Validate method.
	ValidateFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// MessageDescription holds details about calls to the MessageDescription method.
		MessageDescription []struct {
		}
		// ProtoMessage holds details about calls to the ProtoMessage method.
		ProtoMessage []struct {
		}
		// Reset holds details about calls to the Reset method.
		Reset []struct {
		}
		// String holds details about calls to the String method.
		String []struct {
		}
		// Validate holds details about calls to the Validate method.
		Validate []struct {
		}
	}
}

// MessageDescription calls MessageDescriptionFunc.
func (mock *SelfValidatingMessageMock) MessageDescription() string {
	if mock.MessageDescriptionFunc == nil {
		panic("moq: SelfValidatingMessageMock.MessageDescriptionFunc is nil but SelfValidatingMessage.MessageDescription was just called")
	}
	callInfo := struct {
	}{}
	lockSelfValidatingMessageMockMessageDescription.Lock()
	mock.calls.MessageDescription = append(mock.calls.MessageDescription, callInfo)
	lockSelfValidatingMessageMockMessageDescription.Unlock()
	return mock.MessageDescriptionFunc()
}

// MessageDescriptionCalls gets all the calls that were made to MessageDescription.
// Check the length with:
//     len(mockedSelfValidatingMessage.MessageDescriptionCalls())
func (mock *SelfValidatingMessageMock) MessageDescriptionCalls() []struct {
} {
	var calls []struct {
	}
	lockSelfValidatingMessageMockMessageDescription.RLock()
	calls = mock.calls.MessageDescription
	lockSelfValidatingMessageMockMessageDescription.RUnlock()
	return calls
}

// ProtoMessage calls ProtoMessageFunc.
func (mock *SelfValidatingMessageMock) ProtoMessage() {
	if mock.ProtoMessageFunc == nil {
		panic("moq: SelfValidatingMessageMock.ProtoMessageFunc is nil but SelfValidatingMessage.ProtoMessage was just called")
	}
	callInfo := struct {
	}{}
	lockSelfValidatingMessageMockProtoMessage.Lock()
	mock.calls.ProtoMessage = append(mock.calls.ProtoMessage, callInfo)
	lockSelfValidatingMessageMockProtoMessage.Unlock()
	mock.ProtoMessageFunc()
}

// ProtoMessageCalls gets all the calls that were made to ProtoMessage.
// Check the length with:
//     len(mockedSelfValidatingMessage.ProtoMessageCalls())
func (mock *SelfValidatingMessageMock) ProtoMessageCalls() []struct {
} {
	var calls []struct {
	}
	lockSelfValidatingMessageMockProtoMessage.RLock()
	calls = mock.calls.ProtoMessage
	lockSelfValidatingMessageMockProtoMessage.RUnlock()
	return calls
}

// Reset calls ResetFunc.
func (mock *SelfValidatingMessageMock) Reset() {
	if mock.ResetFunc == nil {
		panic("moq: SelfValidatingMessageMock.ResetFunc is nil but SelfValidatingMessage.Reset was just called")
	}
	callInfo := struct {
	}{}
	lockSelfValidatingMessageMockReset.Lock()
	mock.calls.Reset = append(mock.calls.Reset, callInfo)
	lockSelfValidatingMessageMockReset.Unlock()
	mock.ResetFunc()
}

// ResetCalls gets all the calls that were made to Reset.
// Check the length with:
//     len(mockedSelfValidatingMessage.ResetCalls())
func (mock *SelfValidatingMessageMock) ResetCalls() []struct {
} {
	var calls []struct {
	}
	lockSelfValidatingMessageMockReset.RLock()
	calls = mock.calls.Reset
	lockSelfValidatingMessageMockReset.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *SelfValidatingMessageMock) String() string {
	if mock.StringFunc == nil {
		panic("moq: SelfValidatingMessageMock.StringFunc is nil but SelfValidatingMessage.String was just called")
	}
	callInfo := struct {
	}{}
	lockSelfValidatingMessageMockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	lockSelfValidatingMessageMockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//     len(mockedSelfValidatingMessage.StringCalls())
func (mock *SelfValidatingMessageMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	lockSelfValidatingMessageMockString.RLock()
	calls = mock.calls.String
	lockSelfValidatingMessageMockString.RUnlock()
	return calls
}

// Validate calls ValidateFunc.
func (mock *SelfValidatingMessageMock) Validate() error {
	if mock.ValidateFunc == nil {
		panic("moq: SelfValidatingMessageMock.ValidateFunc is nil but SelfValidatingMessage.Validate was just called")
	}
	callInfo := struct {
	}{}
	lockSelfValidatingMessageMockValidate.Lock()
	mock.calls.Validate = append(mock.calls.Validate, callInfo)
	lockSelfValidatingMessageMockValidate.Unlock()
	return mock.ValidateFunc()
}

// ValidateCalls gets all the calls that were made to Validate.
// Check the length with:
//     len(mockedSelfValidatingMessage.ValidateCalls())
func (mock *SelfValidatingMessageMock) ValidateCalls() []struct {
} {
	var calls []struct {
	}
	lockSelfValidatingMessageMockValidate.RLock()
	calls = mock.calls.Validate
	lockSelfValidatingMessageMockValidate.RUnlock()
	return calls
}

var (
	lockTransportMockInitialize sync.RWMutex
	lockTransportMockReceive    sync.RWMutex
	lockTransportMockSend       sync.RWMutex
	lockTransportMockSubscribe  sync.RWMutex
)

// TransportMock is a mock implementation of Transport.
//
//     func TestSomethingThatUsesTransport(t *testing.T) {
//
//         // make and configure a mocked Transport
//         mockedTransport := &TransportMock{
//             InitializeFunc: func(ctx context.Context, ep string) error {
// 	               panic("TODO: mock out the Initialize method")
//             },
//             ReceiveFunc: func(ctx context.Context) (endpoint.InboundEnvelope, endpoint.Acknowledger, error) {
// 	               panic("TODO: mock out the Receive method")
//             },
//             SendFunc: func(ctx context.Context, env endpoint.OutboundEnvelope) error {
// 	               panic("TODO: mock out the Send method")
//             },
//             SubscribeFunc: func(ctx context.Context, op endpoint.Operation, mt ax.MessageTypeSet) error {
// 	               panic("TODO: mock out the Subscribe method")
//             },
//         }
//
//         // TODO: use mockedTransport in code that requires Transport
//         //       and then make assertions.
//
//     }
type TransportMock struct {
	// InitializeFunc mocks the Initialize method.
	InitializeFunc func(ctx context.Context, ep string) error

	// ReceiveFunc mocks the Receive method.
	ReceiveFunc func(ctx context.Context) (endpoint.InboundEnvelope, endpoint.Acknowledger, error)

	// SendFunc mocks the Send method.
	SendFunc func(ctx context.Context, env endpoint.OutboundEnvelope) error

	// SubscribeFunc mocks the Subscribe method.
	SubscribeFunc func(ctx context.Context, op endpoint.Operation, mt ax.MessageTypeSet) error

	// calls tracks calls to the methods.
	calls struct {
		// Initialize holds details about calls to the Initialize method.
		Initialize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ep is the ep argument value.
			Ep string
		}
		// Receive holds details about calls to the Receive method.
		Receive []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Send holds details about calls to the Send method.
		Send []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Env is the env argument value.
			Env endpoint.OutboundEnvelope
		}
		// Subscribe holds details about calls to the Subscribe method.
		Subscribe []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Op is the op argument value.
			Op endpoint.Operation
			// Mt is the mt argument value.
			Mt ax.MessageTypeSet
		}
	}
}

// Initialize calls InitializeFunc.
func (mock *TransportMock) Initialize(ctx context.Context, ep string) error {
	if mock.InitializeFunc == nil {
		panic("moq: TransportMock.InitializeFunc is nil but Transport.Initialize was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ep  string
	}{
		Ctx: ctx,
		Ep:  ep,
	}
	lockTransportMockInitialize.Lock()
	mock.calls.Initialize = append(mock.calls.Initialize, callInfo)
	lockTransportMockInitialize.Unlock()
	return mock.InitializeFunc(ctx, ep)
}

// InitializeCalls gets all the calls that were made to Initialize.
// Check the length with:
//     len(mockedTransport.InitializeCalls())
func (mock *TransportMock) InitializeCalls() []struct {
	Ctx context.Context
	Ep  string
} {
	var calls []struct {
		Ctx context.Context
		Ep  string
	}
	lockTransportMockInitialize.RLock()
	calls = mock.calls.Initialize
	lockTransportMockInitialize.RUnlock()
	return calls
}

// Receive calls ReceiveFunc.
func (mock *TransportMock) Receive(ctx context.Context) (endpoint.InboundEnvelope, endpoint.Acknowledger, error) {
	if mock.ReceiveFunc == nil {
		panic("moq: TransportMock.ReceiveFunc is nil but Transport.Receive was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	lockTransportMockReceive.Lock()
	mock.calls.Receive = append(mock.calls.Receive, callInfo)
	lockTransportMockReceive.Unlock()
	return mock.ReceiveFunc(ctx)
}

// ReceiveCalls gets all the calls that were made to Receive.
// Check the length with:
//     len(mockedTransport.ReceiveCalls())
func (mock *TransportMock) ReceiveCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	lockTransportMockReceive.RLock()
	calls = mock.calls.Receive
	lockTransportMockReceive.RUnlock()
	return calls
}

// Send calls SendFunc.
func (mock *TransportMock) Send(ctx context.Context, env endpoint.OutboundEnvelope) error {
	if mock.SendFunc == nil {
		panic("moq: TransportMock.SendFunc is nil but Transport.Send was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
	}{
		Ctx: ctx,
		Env: env,
	}
	lockTransportMockSend.Lock()
	mock.calls.Send = append(mock.calls.Send, callInfo)
	lockTransportMockSend.Unlock()
	return mock.SendFunc(ctx, env)
}

// SendCalls gets all the calls that were made to Send.
// Check the length with:
//     len(mockedTransport.SendCalls())
func (mock *TransportMock) SendCalls() []struct {
	Ctx context.Context
	Env endpoint.OutboundEnvelope
} {
	var calls []struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
	}
	lockTransportMockSend.RLock()
	calls = mock.calls.Send
	lockTransportMockSend.RUnlock()
	return calls
}

// Subscribe calls SubscribeFunc.
func (mock *TransportMock) Subscribe(ctx context.Context, op endpoint.Operation, mt ax.MessageTypeSet) error {
	if mock.SubscribeFunc == nil {
		panic("moq: TransportMock.SubscribeFunc is nil but Transport.Subscribe was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Op  endpoint.Operation
		Mt  ax.MessageTypeSet
	}{
		Ctx: ctx,
		Op:  op,
		Mt:  mt,
	}
	lockTransportMockSubscribe.Lock()
	mock.calls.Subscribe = append(mock.calls.Subscribe, callInfo)
	lockTransportMockSubscribe.Unlock()
	return mock.SubscribeFunc(ctx, op, mt)
}

// SubscribeCalls gets all the calls that were made to Subscribe.
// Check the length with:
//     len(mockedTransport.SubscribeCalls())
func (mock *TransportMock) SubscribeCalls() []struct {
	Ctx context.Context
	Op  endpoint.Operation
	Mt  ax.MessageTypeSet
} {
	var calls []struct {
		Ctx context.Context
		Op  endpoint.Operation
		Mt  ax.MessageTypeSet
	}
	lockTransportMockSubscribe.RLock()
	calls = mock.calls.Subscribe
	lockTransportMockSubscribe.RUnlock()
	return calls
}

var (
	lockValidatorMockValidate sync.RWMutex
)

// ValidatorMock is a mock implementation of Validator.
//
//     func TestSomethingThatUsesValidator(t *testing.T) {
//
//         // make and configure a mocked Validator
//         mockedValidator := &ValidatorMock{
//             ValidateFunc: func(ctx context.Context, m ax.Message) error {
// 	               panic("TODO: mock out the Validate method")
//             },
//         }
//
//         // TODO: use mockedValidator in code that requires Validator
//         //       and then make assertions.
//
//     }
type ValidatorMock struct {
	// ValidateFunc mocks the Validate method.
	ValidateFunc func(ctx context.Context, m ax.Message) error

	// calls tracks calls to the methods.
	calls struct {
		// Validate holds details about calls to the Validate method.
		Validate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// M is the m argument value.
			M ax.Message
		}
	}
}

// Validate calls ValidateFunc.
func (mock *ValidatorMock) Validate(ctx context.Context, m ax.Message) error {
	if mock.ValidateFunc == nil {
		panic("moq: ValidatorMock.ValidateFunc is nil but Validator.Validate was just called")
	}
	callInfo := struct {
		Ctx context.Context
		M   ax.Message
	}{
		Ctx: ctx,
		M:   m,
	}
	lockValidatorMockValidate.Lock()
	mock.calls.Validate = append(mock.calls.Validate, callInfo)
	lockValidatorMockValidate.Unlock()
	return mock.ValidateFunc(ctx, m)
}

// ValidateCalls gets all the calls that were made to Validate.
// Check the length with:
//     len(mockedValidator.ValidateCalls())
func (mock *ValidatorMock) ValidateCalls() []struct {
	Ctx context.Context
	M   ax.Message
} {
	var calls []struct {
		Ctx context.Context
		M   ax.Message
	}
	lockValidatorMockValidate.RLock()
	calls = mock.calls.Validate
	lockValidatorMockValidate.RUnlock()
	return calls
}
