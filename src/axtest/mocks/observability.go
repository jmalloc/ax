// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/jmalloc/ax/src/ax/endpoint"
	"sync"
)

var (
	lockAfterInboundObserverMockAfterInbound sync.RWMutex
)

// AfterInboundObserverMock is a mock implementation of AfterInboundObserver.
//
//     func TestSomethingThatUsesAfterInboundObserver(t *testing.T) {
//
//         // make and configure a mocked AfterInboundObserver
//         mockedAfterInboundObserver := &AfterInboundObserverMock{
//             AfterInboundFunc: func(ctx context.Context, env endpoint.InboundEnvelope, err error)  {
// 	               panic("TODO: mock out the AfterInbound method")
//             },
//         }
//
//         // TODO: use mockedAfterInboundObserver in code that requires AfterInboundObserver
//         //       and then make assertions.
//
//     }
type AfterInboundObserverMock struct {
	// AfterInboundFunc mocks the AfterInbound method.
	AfterInboundFunc func(ctx context.Context, env endpoint.InboundEnvelope, err error)

	// calls tracks calls to the methods.
	calls struct {
		// AfterInbound holds details about calls to the AfterInbound method.
		AfterInbound []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Env is the env argument value.
			Env endpoint.InboundEnvelope
			// Err is the err argument value.
			Err error
		}
	}
}

// AfterInbound calls AfterInboundFunc.
func (mock *AfterInboundObserverMock) AfterInbound(ctx context.Context, env endpoint.InboundEnvelope, err error) {
	if mock.AfterInboundFunc == nil {
		panic("moq: AfterInboundObserverMock.AfterInboundFunc is nil but AfterInboundObserver.AfterInbound was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Env endpoint.InboundEnvelope
		Err error
	}{
		Ctx: ctx,
		Env: env,
		Err: err,
	}
	lockAfterInboundObserverMockAfterInbound.Lock()
	mock.calls.AfterInbound = append(mock.calls.AfterInbound, callInfo)
	lockAfterInboundObserverMockAfterInbound.Unlock()
	mock.AfterInboundFunc(ctx, env, err)
}

// AfterInboundCalls gets all the calls that were made to AfterInbound.
// Check the length with:
//     len(mockedAfterInboundObserver.AfterInboundCalls())
func (mock *AfterInboundObserverMock) AfterInboundCalls() []struct {
	Ctx context.Context
	Env endpoint.InboundEnvelope
	Err error
} {
	var calls []struct {
		Ctx context.Context
		Env endpoint.InboundEnvelope
		Err error
	}
	lockAfterInboundObserverMockAfterInbound.RLock()
	calls = mock.calls.AfterInbound
	lockAfterInboundObserverMockAfterInbound.RUnlock()
	return calls
}

var (
	lockAfterOutboundObserverMockAfterOutbound sync.RWMutex
)

// AfterOutboundObserverMock is a mock implementation of AfterOutboundObserver.
//
//     func TestSomethingThatUsesAfterOutboundObserver(t *testing.T) {
//
//         // make and configure a mocked AfterOutboundObserver
//         mockedAfterOutboundObserver := &AfterOutboundObserverMock{
//             AfterOutboundFunc: func(ctx context.Context, env endpoint.OutboundEnvelope, err error)  {
// 	               panic("TODO: mock out the AfterOutbound method")
//             },
//         }
//
//         // TODO: use mockedAfterOutboundObserver in code that requires AfterOutboundObserver
//         //       and then make assertions.
//
//     }
type AfterOutboundObserverMock struct {
	// AfterOutboundFunc mocks the AfterOutbound method.
	AfterOutboundFunc func(ctx context.Context, env endpoint.OutboundEnvelope, err error)

	// calls tracks calls to the methods.
	calls struct {
		// AfterOutbound holds details about calls to the AfterOutbound method.
		AfterOutbound []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Env is the env argument value.
			Env endpoint.OutboundEnvelope
			// Err is the err argument value.
			Err error
		}
	}
}

// AfterOutbound calls AfterOutboundFunc.
func (mock *AfterOutboundObserverMock) AfterOutbound(ctx context.Context, env endpoint.OutboundEnvelope, err error) {
	if mock.AfterOutboundFunc == nil {
		panic("moq: AfterOutboundObserverMock.AfterOutboundFunc is nil but AfterOutboundObserver.AfterOutbound was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
		Err error
	}{
		Ctx: ctx,
		Env: env,
		Err: err,
	}
	lockAfterOutboundObserverMockAfterOutbound.Lock()
	mock.calls.AfterOutbound = append(mock.calls.AfterOutbound, callInfo)
	lockAfterOutboundObserverMockAfterOutbound.Unlock()
	mock.AfterOutboundFunc(ctx, env, err)
}

// AfterOutboundCalls gets all the calls that were made to AfterOutbound.
// Check the length with:
//     len(mockedAfterOutboundObserver.AfterOutboundCalls())
func (mock *AfterOutboundObserverMock) AfterOutboundCalls() []struct {
	Ctx context.Context
	Env endpoint.OutboundEnvelope
	Err error
} {
	var calls []struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
		Err error
	}
	lockAfterOutboundObserverMockAfterOutbound.RLock()
	calls = mock.calls.AfterOutbound
	lockAfterOutboundObserverMockAfterOutbound.RUnlock()
	return calls
}

var (
	lockBeforeInboundObserverMockBeforeInbound sync.RWMutex
)

// BeforeInboundObserverMock is a mock implementation of BeforeInboundObserver.
//
//     func TestSomethingThatUsesBeforeInboundObserver(t *testing.T) {
//
//         // make and configure a mocked BeforeInboundObserver
//         mockedBeforeInboundObserver := &BeforeInboundObserverMock{
//             BeforeInboundFunc: func(ctx context.Context, env endpoint.InboundEnvelope)  {
// 	               panic("TODO: mock out the BeforeInbound method")
//             },
//         }
//
//         // TODO: use mockedBeforeInboundObserver in code that requires BeforeInboundObserver
//         //       and then make assertions.
//
//     }
type BeforeInboundObserverMock struct {
	// BeforeInboundFunc mocks the BeforeInbound method.
	BeforeInboundFunc func(ctx context.Context, env endpoint.InboundEnvelope)

	// calls tracks calls to the methods.
	calls struct {
		// BeforeInbound holds details about calls to the BeforeInbound method.
		BeforeInbound []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Env is the env argument value.
			Env endpoint.InboundEnvelope
		}
	}
}

// BeforeInbound calls BeforeInboundFunc.
func (mock *BeforeInboundObserverMock) BeforeInbound(ctx context.Context, env endpoint.InboundEnvelope) {
	if mock.BeforeInboundFunc == nil {
		panic("moq: BeforeInboundObserverMock.BeforeInboundFunc is nil but BeforeInboundObserver.BeforeInbound was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Env endpoint.InboundEnvelope
	}{
		Ctx: ctx,
		Env: env,
	}
	lockBeforeInboundObserverMockBeforeInbound.Lock()
	mock.calls.BeforeInbound = append(mock.calls.BeforeInbound, callInfo)
	lockBeforeInboundObserverMockBeforeInbound.Unlock()
	mock.BeforeInboundFunc(ctx, env)
}

// BeforeInboundCalls gets all the calls that were made to BeforeInbound.
// Check the length with:
//     len(mockedBeforeInboundObserver.BeforeInboundCalls())
func (mock *BeforeInboundObserverMock) BeforeInboundCalls() []struct {
	Ctx context.Context
	Env endpoint.InboundEnvelope
} {
	var calls []struct {
		Ctx context.Context
		Env endpoint.InboundEnvelope
	}
	lockBeforeInboundObserverMockBeforeInbound.RLock()
	calls = mock.calls.BeforeInbound
	lockBeforeInboundObserverMockBeforeInbound.RUnlock()
	return calls
}

var (
	lockBeforeOutboundObserverMockBeforeOutbound sync.RWMutex
)

// BeforeOutboundObserverMock is a mock implementation of BeforeOutboundObserver.
//
//     func TestSomethingThatUsesBeforeOutboundObserver(t *testing.T) {
//
//         // make and configure a mocked BeforeOutboundObserver
//         mockedBeforeOutboundObserver := &BeforeOutboundObserverMock{
//             BeforeOutboundFunc: func(ctx context.Context, env endpoint.OutboundEnvelope)  {
// 	               panic("TODO: mock out the BeforeOutbound method")
//             },
//         }
//
//         // TODO: use mockedBeforeOutboundObserver in code that requires BeforeOutboundObserver
//         //       and then make assertions.
//
//     }
type BeforeOutboundObserverMock struct {
	// BeforeOutboundFunc mocks the BeforeOutbound method.
	BeforeOutboundFunc func(ctx context.Context, env endpoint.OutboundEnvelope)

	// calls tracks calls to the methods.
	calls struct {
		// BeforeOutbound holds details about calls to the BeforeOutbound method.
		BeforeOutbound []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Env is the env argument value.
			Env endpoint.OutboundEnvelope
		}
	}
}

// BeforeOutbound calls BeforeOutboundFunc.
func (mock *BeforeOutboundObserverMock) BeforeOutbound(ctx context.Context, env endpoint.OutboundEnvelope) {
	if mock.BeforeOutboundFunc == nil {
		panic("moq: BeforeOutboundObserverMock.BeforeOutboundFunc is nil but BeforeOutboundObserver.BeforeOutbound was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
	}{
		Ctx: ctx,
		Env: env,
	}
	lockBeforeOutboundObserverMockBeforeOutbound.Lock()
	mock.calls.BeforeOutbound = append(mock.calls.BeforeOutbound, callInfo)
	lockBeforeOutboundObserverMockBeforeOutbound.Unlock()
	mock.BeforeOutboundFunc(ctx, env)
}

// BeforeOutboundCalls gets all the calls that were made to BeforeOutbound.
// Check the length with:
//     len(mockedBeforeOutboundObserver.BeforeOutboundCalls())
func (mock *BeforeOutboundObserverMock) BeforeOutboundCalls() []struct {
	Ctx context.Context
	Env endpoint.OutboundEnvelope
} {
	var calls []struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
	}
	lockBeforeOutboundObserverMockBeforeOutbound.RLock()
	calls = mock.calls.BeforeOutbound
	lockBeforeOutboundObserverMockBeforeOutbound.RUnlock()
	return calls
}
