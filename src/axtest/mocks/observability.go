// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/jmalloc/ax/src/ax/endpoint"
	"sync"
)

var (
	lockInboundObserverMockAfterInbound      sync.RWMutex
	lockInboundObserverMockBeforeInbound     sync.RWMutex
	lockInboundObserverMockInitializeInbound sync.RWMutex
)

// InboundObserverMock is a mock implementation of InboundObserver.
//
//     func TestSomethingThatUsesInboundObserver(t *testing.T) {
//
//         // make and configure a mocked InboundObserver
//         mockedInboundObserver := &InboundObserverMock{
//             AfterInboundFunc: func(ctx context.Context, env endpoint.InboundEnvelope, err error)  {
// 	               panic("TODO: mock out the AfterInbound method")
//             },
//             BeforeInboundFunc: func(ctx context.Context, env endpoint.InboundEnvelope)  {
// 	               panic("TODO: mock out the BeforeInbound method")
//             },
//             InitializeInboundFunc: func(ctx context.Context, ep *endpoint.Endpoint) error {
// 	               panic("TODO: mock out the InitializeInbound method")
//             },
//         }
//
//         // TODO: use mockedInboundObserver in code that requires InboundObserver
//         //       and then make assertions.
//
//     }
type InboundObserverMock struct {
	// AfterInboundFunc mocks the AfterInbound method.
	AfterInboundFunc func(ctx context.Context, env endpoint.InboundEnvelope, err error)

	// BeforeInboundFunc mocks the BeforeInbound method.
	BeforeInboundFunc func(ctx context.Context, env endpoint.InboundEnvelope)

	// InitializeInboundFunc mocks the InitializeInbound method.
	InitializeInboundFunc func(ctx context.Context, ep *endpoint.Endpoint) error

	// calls tracks calls to the methods.
	calls struct {
		// AfterInbound holds details about calls to the AfterInbound method.
		AfterInbound []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Env is the env argument value.
			Env endpoint.InboundEnvelope
			// Err is the err argument value.
			Err error
		}
		// BeforeInbound holds details about calls to the BeforeInbound method.
		BeforeInbound []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Env is the env argument value.
			Env endpoint.InboundEnvelope
		}
		// InitializeInbound holds details about calls to the InitializeInbound method.
		InitializeInbound []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ep is the ep argument value.
			Ep *endpoint.Endpoint
		}
	}
}

// AfterInbound calls AfterInboundFunc.
func (mock *InboundObserverMock) AfterInbound(ctx context.Context, env endpoint.InboundEnvelope, err error) {
	if mock.AfterInboundFunc == nil {
		panic("InboundObserverMock.AfterInboundFunc: method is nil but InboundObserver.AfterInbound was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Env endpoint.InboundEnvelope
		Err error
	}{
		Ctx: ctx,
		Env: env,
		Err: err,
	}
	lockInboundObserverMockAfterInbound.Lock()
	mock.calls.AfterInbound = append(mock.calls.AfterInbound, callInfo)
	lockInboundObserverMockAfterInbound.Unlock()
	mock.AfterInboundFunc(ctx, env, err)
}

// AfterInboundCalls gets all the calls that were made to AfterInbound.
// Check the length with:
//     len(mockedInboundObserver.AfterInboundCalls())
func (mock *InboundObserverMock) AfterInboundCalls() []struct {
	Ctx context.Context
	Env endpoint.InboundEnvelope
	Err error
} {
	var calls []struct {
		Ctx context.Context
		Env endpoint.InboundEnvelope
		Err error
	}
	lockInboundObserverMockAfterInbound.RLock()
	calls = mock.calls.AfterInbound
	lockInboundObserverMockAfterInbound.RUnlock()
	return calls
}

// BeforeInbound calls BeforeInboundFunc.
func (mock *InboundObserverMock) BeforeInbound(ctx context.Context, env endpoint.InboundEnvelope) {
	if mock.BeforeInboundFunc == nil {
		panic("InboundObserverMock.BeforeInboundFunc: method is nil but InboundObserver.BeforeInbound was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Env endpoint.InboundEnvelope
	}{
		Ctx: ctx,
		Env: env,
	}
	lockInboundObserverMockBeforeInbound.Lock()
	mock.calls.BeforeInbound = append(mock.calls.BeforeInbound, callInfo)
	lockInboundObserverMockBeforeInbound.Unlock()
	mock.BeforeInboundFunc(ctx, env)
}

// BeforeInboundCalls gets all the calls that were made to BeforeInbound.
// Check the length with:
//     len(mockedInboundObserver.BeforeInboundCalls())
func (mock *InboundObserverMock) BeforeInboundCalls() []struct {
	Ctx context.Context
	Env endpoint.InboundEnvelope
} {
	var calls []struct {
		Ctx context.Context
		Env endpoint.InboundEnvelope
	}
	lockInboundObserverMockBeforeInbound.RLock()
	calls = mock.calls.BeforeInbound
	lockInboundObserverMockBeforeInbound.RUnlock()
	return calls
}

// InitializeInbound calls InitializeInboundFunc.
func (mock *InboundObserverMock) InitializeInbound(ctx context.Context, ep *endpoint.Endpoint) error {
	if mock.InitializeInboundFunc == nil {
		panic("InboundObserverMock.InitializeInboundFunc: method is nil but InboundObserver.InitializeInbound was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ep  *endpoint.Endpoint
	}{
		Ctx: ctx,
		Ep:  ep,
	}
	lockInboundObserverMockInitializeInbound.Lock()
	mock.calls.InitializeInbound = append(mock.calls.InitializeInbound, callInfo)
	lockInboundObserverMockInitializeInbound.Unlock()
	return mock.InitializeInboundFunc(ctx, ep)
}

// InitializeInboundCalls gets all the calls that were made to InitializeInbound.
// Check the length with:
//     len(mockedInboundObserver.InitializeInboundCalls())
func (mock *InboundObserverMock) InitializeInboundCalls() []struct {
	Ctx context.Context
	Ep  *endpoint.Endpoint
} {
	var calls []struct {
		Ctx context.Context
		Ep  *endpoint.Endpoint
	}
	lockInboundObserverMockInitializeInbound.RLock()
	calls = mock.calls.InitializeInbound
	lockInboundObserverMockInitializeInbound.RUnlock()
	return calls
}

var (
	lockOutboundObserverMockAfterOutbound      sync.RWMutex
	lockOutboundObserverMockBeforeOutbound     sync.RWMutex
	lockOutboundObserverMockInitializeOutbound sync.RWMutex
)

// OutboundObserverMock is a mock implementation of OutboundObserver.
//
//     func TestSomethingThatUsesOutboundObserver(t *testing.T) {
//
//         // make and configure a mocked OutboundObserver
//         mockedOutboundObserver := &OutboundObserverMock{
//             AfterOutboundFunc: func(ctx context.Context, env endpoint.OutboundEnvelope, err error)  {
// 	               panic("TODO: mock out the AfterOutbound method")
//             },
//             BeforeOutboundFunc: func(ctx context.Context, env endpoint.OutboundEnvelope)  {
// 	               panic("TODO: mock out the BeforeOutbound method")
//             },
//             InitializeOutboundFunc: func(ctx context.Context, ep *endpoint.Endpoint) error {
// 	               panic("TODO: mock out the InitializeOutbound method")
//             },
//         }
//
//         // TODO: use mockedOutboundObserver in code that requires OutboundObserver
//         //       and then make assertions.
//
//     }
type OutboundObserverMock struct {
	// AfterOutboundFunc mocks the AfterOutbound method.
	AfterOutboundFunc func(ctx context.Context, env endpoint.OutboundEnvelope, err error)

	// BeforeOutboundFunc mocks the BeforeOutbound method.
	BeforeOutboundFunc func(ctx context.Context, env endpoint.OutboundEnvelope)

	// InitializeOutboundFunc mocks the InitializeOutbound method.
	InitializeOutboundFunc func(ctx context.Context, ep *endpoint.Endpoint) error

	// calls tracks calls to the methods.
	calls struct {
		// AfterOutbound holds details about calls to the AfterOutbound method.
		AfterOutbound []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Env is the env argument value.
			Env endpoint.OutboundEnvelope
			// Err is the err argument value.
			Err error
		}
		// BeforeOutbound holds details about calls to the BeforeOutbound method.
		BeforeOutbound []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Env is the env argument value.
			Env endpoint.OutboundEnvelope
		}
		// InitializeOutbound holds details about calls to the InitializeOutbound method.
		InitializeOutbound []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ep is the ep argument value.
			Ep *endpoint.Endpoint
		}
	}
}

// AfterOutbound calls AfterOutboundFunc.
func (mock *OutboundObserverMock) AfterOutbound(ctx context.Context, env endpoint.OutboundEnvelope, err error) {
	if mock.AfterOutboundFunc == nil {
		panic("OutboundObserverMock.AfterOutboundFunc: method is nil but OutboundObserver.AfterOutbound was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
		Err error
	}{
		Ctx: ctx,
		Env: env,
		Err: err,
	}
	lockOutboundObserverMockAfterOutbound.Lock()
	mock.calls.AfterOutbound = append(mock.calls.AfterOutbound, callInfo)
	lockOutboundObserverMockAfterOutbound.Unlock()
	mock.AfterOutboundFunc(ctx, env, err)
}

// AfterOutboundCalls gets all the calls that were made to AfterOutbound.
// Check the length with:
//     len(mockedOutboundObserver.AfterOutboundCalls())
func (mock *OutboundObserverMock) AfterOutboundCalls() []struct {
	Ctx context.Context
	Env endpoint.OutboundEnvelope
	Err error
} {
	var calls []struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
		Err error
	}
	lockOutboundObserverMockAfterOutbound.RLock()
	calls = mock.calls.AfterOutbound
	lockOutboundObserverMockAfterOutbound.RUnlock()
	return calls
}

// BeforeOutbound calls BeforeOutboundFunc.
func (mock *OutboundObserverMock) BeforeOutbound(ctx context.Context, env endpoint.OutboundEnvelope) {
	if mock.BeforeOutboundFunc == nil {
		panic("OutboundObserverMock.BeforeOutboundFunc: method is nil but OutboundObserver.BeforeOutbound was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
	}{
		Ctx: ctx,
		Env: env,
	}
	lockOutboundObserverMockBeforeOutbound.Lock()
	mock.calls.BeforeOutbound = append(mock.calls.BeforeOutbound, callInfo)
	lockOutboundObserverMockBeforeOutbound.Unlock()
	mock.BeforeOutboundFunc(ctx, env)
}

// BeforeOutboundCalls gets all the calls that were made to BeforeOutbound.
// Check the length with:
//     len(mockedOutboundObserver.BeforeOutboundCalls())
func (mock *OutboundObserverMock) BeforeOutboundCalls() []struct {
	Ctx context.Context
	Env endpoint.OutboundEnvelope
} {
	var calls []struct {
		Ctx context.Context
		Env endpoint.OutboundEnvelope
	}
	lockOutboundObserverMockBeforeOutbound.RLock()
	calls = mock.calls.BeforeOutbound
	lockOutboundObserverMockBeforeOutbound.RUnlock()
	return calls
}

// InitializeOutbound calls InitializeOutboundFunc.
func (mock *OutboundObserverMock) InitializeOutbound(ctx context.Context, ep *endpoint.Endpoint) error {
	if mock.InitializeOutboundFunc == nil {
		panic("OutboundObserverMock.InitializeOutboundFunc: method is nil but OutboundObserver.InitializeOutbound was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ep  *endpoint.Endpoint
	}{
		Ctx: ctx,
		Ep:  ep,
	}
	lockOutboundObserverMockInitializeOutbound.Lock()
	mock.calls.InitializeOutbound = append(mock.calls.InitializeOutbound, callInfo)
	lockOutboundObserverMockInitializeOutbound.Unlock()
	return mock.InitializeOutboundFunc(ctx, ep)
}

// InitializeOutboundCalls gets all the calls that were made to InitializeOutbound.
// Check the length with:
//     len(mockedOutboundObserver.InitializeOutboundCalls())
func (mock *OutboundObserverMock) InitializeOutboundCalls() []struct {
	Ctx context.Context
	Ep  *endpoint.Endpoint
} {
	var calls []struct {
		Ctx context.Context
		Ep  *endpoint.Endpoint
	}
	lockOutboundObserverMockInitializeOutbound.RLock()
	calls = mock.calls.InitializeOutbound
	lockOutboundObserverMockInitializeOutbound.RUnlock()
	return calls
}
